<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Randomized enumeration of IP addresses in a subnet | lthibau.lt</title>
<meta name="keywords" content="">
<meta name="description" content="I recently encountered a problem that seemed trivial on the surface, and turned out to be challenging enough to warrant a blog post:
Given a subnet, iterate through its addresses in pseudorandom order.
Naive Approach For small subnets like 10.8.1.0/24, the naive implementation works well. We enumerate each address and append it to a list, shuffle the list, and then range over the list. The first step is the only one I had to stop and think about, but it ended up being quite straightforward.">
<meta name="author" content="">
<link rel="canonical" href="https://lthibault.github.io/posts/random-cidr-iter/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://lthibault.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://lthibault.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://lthibault.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://lthibault.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://lthibault.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Randomized enumeration of IP addresses in a subnet" />
<meta property="og:description" content="I recently encountered a problem that seemed trivial on the surface, and turned out to be challenging enough to warrant a blog post:
Given a subnet, iterate through its addresses in pseudorandom order.
Naive Approach For small subnets like 10.8.1.0/24, the naive implementation works well. We enumerate each address and append it to a list, shuffle the list, and then range over the list. The first step is the only one I had to stop and think about, but it ended up being quite straightforward." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://lthibault.github.io/posts/random-cidr-iter/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-18T09:09:10-05:00" />
<meta property="article:modified_time" content="2022-11-18T09:09:10-05:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Randomized enumeration of IP addresses in a subnet"/>
<meta name="twitter:description" content="I recently encountered a problem that seemed trivial on the surface, and turned out to be challenging enough to warrant a blog post:
Given a subnet, iterate through its addresses in pseudorandom order.
Naive Approach For small subnets like 10.8.1.0/24, the naive implementation works well. We enumerate each address and append it to a list, shuffle the list, and then range over the list. The first step is the only one I had to stop and think about, but it ended up being quite straightforward."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://lthibault.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Randomized enumeration of IP addresses in a subnet",
      "item": "https://lthibault.github.io/posts/random-cidr-iter/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Randomized enumeration of IP addresses in a subnet",
  "name": "Randomized enumeration of IP addresses in a subnet",
  "description": "I recently encountered a problem that seemed trivial on the surface, and turned out to be challenging enough to warrant a blog post:\nGiven a subnet, iterate through its addresses in pseudorandom order.\nNaive Approach For small subnets like 10.8.1.0/24, the naive implementation works well. We enumerate each address and append it to a list, shuffle the list, and then range over the list. The first step is the only one I had to stop and think about, but it ended up being quite straightforward.",
  "keywords": [
    
  ],
  "articleBody": "I recently encountered a problem that seemed trivial on the surface, and turned out to be challenging enough to warrant a blog post:\nGiven a subnet, iterate through its addresses in pseudorandom order.\nNaive Approach For small subnets like 10.8.1.0/24, the naive implementation works well. We enumerate each address and append it to a list, shuffle the list, and then range over the list. The first step is the only one I had to stop and think about, but it ended up being quite straightforward. Here’s its implementation in Go, with some extra comments to make it more obvious:\nfunc incrIP(ip net.IP) { // Iterate over ip's bytes in reverse order for i := len(ip) - 1; i \u003e= 0; i-- { // Increment the current byte. If it wraps around to zero, // continue with the next byte, else we're done. if ip[i]++; ip[i] \u003e 0 { break } } } With a /16 subnet, the list-shuffling approach remains feasible, but starts to feel sloppy. It requires allocating a 256 KB list. With /8, the size grows to 64 MB. And if we’re dealing with IPv6, that number can grow much larger.\nFortunately, there is a way to iterate through arbitrarily-large subnets with constant memory. I can’t imagine I’m the first to discover this trick, but I confess to having felt a shivver of satisfaction when it clicked into place. The intuition is simple: generate a random bitmask and XOR it with the unmasked bits in the subnet. The essential challenge boils down to some unobvious, albeit insanely satisfying, bit-twiddling.\nA Brief Aside: XOR I love XOR; it’s my favorite boolean operator. Even after all these years, it strikes me as quirky when compared to the more pedestrian AND, OR and NOT, yet it seems to turn up everywhere, and for good reason! XOR has algebraic properties that make it arguably less quirky and more well-behaved than most of it siblings, and incredibly useful.\nIt seems unnecessary to introduce a definition of XOR, given its familiarity to most developers, but it can be helpful to check its more interesting properties against a truth-table. In essence, A ⊕ B is true if either A or B is true, but not both.\nA B A ⊕ B 0 0 0 0 1 1 1 0 1 1 1 0 This naturally extends to bitwise operations on binary integers. XOR-ing the 8-bit binary integer 0111 1111 with 1111 1110 produces 1000 0001. Each bit from the first integer is XORed with the corresponding bit on the second integer to produce the result.\nFour properties of XOR deserve special mention. First, A ⊕ 0 = A, for any A. This follows from the definition of XOR. In other words, XOR-ing by zero acts as the identity property.\nSimilarly, A ⊕ 1 = ¬A, for any A. This also follows from the definition of XOR, and acts as an inverse property.\nThe third property we shall call the complementary property. For any A, B and C, such that A ⊕ B = C, A ⊕ C = B and B ⊕ C = A.\nThis brings us to the fourth and final notable property: the uniqueness property. For any A, B, X and Y, if A ⊕ B = C and X ⊕ Y = C, then A = X and B = Y, or A = Y and B = X. In other words, XOR-ing a pair of 8-bit integers produces an 8-bit integer that is unique to that pair.\nProof (by contradiction). Let A ⊕ B = C. By the complementary property, A ⊕ C = B. Now, suppose there is an X ≠ B such that A ⊕ X = C. Then, A ⊕ C = X, and we arrive at a contradiction. ⃞\nXOR Bit-Mask Approach The uniqueness property turns out to be essential, as it provides us with a way of randomizing the enumeration-order of an integer range without resorting to list-construction. Instead, we can generate a random mask, and then iterate through the integer range in-order, XOR-ing each integer with the mask.\nconst mask = 0xd3 // random value for i := 0; i \u003c 256; i++ { fmt.Println(i^mask) } We’re now inches away from a solution. The only wrinkle is that IP subnets are multiple bytes in length, and have a constant prefix that must not be modified by the XOR-mask. In 10.8.1.0/24, only the last 8 bits should be randomized, for example.\nLet’s start with an buggy implementation and refine it progressively. Assume the subnet 10.8.1.0/24. The corresponding subnet mask is 255.255.255.0.\n/* BUG. Modifies the subnet address prefix. */ var subnet = net.IPNet{ IP: net.IP{10, 8, 1, 0}, Mask: IPMask{255, 255, 255, 0}, } // Create a random mask of the same length as an IPv4 address mask := make([]byte, 4) rand.Read(mask) // Range over subnet IPs var ip = make([]byte, 4) for subnet.Contains(subnet.IP) { for i, b := range subnet.IP { ip[i] = b^mask[i] } fmt.Println(ip) incrIP(subnet.IP) } If you run this code, you’ll observe that the final byte of the printed addresses behaves as expected. However, the constant prefix will be mangled with near certainty. To remedy this, we’ll need our identity and inverse properties.\nvar subnet = net.IPNet{ IP: net.IP{10, 8, 1, 0}, Mask: IPMask{255, 255, 255, 0}, } // Create a random mask of the same length as an IPv4 address mask := make([]byte, 4) rand.Read(mask) // let's say this now contains 42.124.33.77 // Get the inverse of the subnet mask. inverse := make([]byte, 4) copy(inverse, subnet.Mask) // contains 255.255.255.0 xor(inverse, []byte{255, 255, 255, 255}) // now contains 0.0.0.255 // Zero-out the 3 leftmost bytes in the random mask, corresponding // to the original (non-inverted) subnet mask. xor(mask, inverse) // mask now contains 0.0.0.77 var ip = make([]byte, 4) for subnet.Contains(subnet.IP) { copy(ip, subnet.IP) xor(ip, mask) // contains 10.8.1.x, where x = 77 ⊕ subnet.IP[3] fmt.Println(ip) incrIP(subnet.IP) } We define the helper function xor as follows:\nfunc xor(x, y []byte) { for i := range x { x[i] ^= y[i] } } And voila! You now have pseudorandom iteration through a subnet with O(1) memory usage! And it’s blazing fast, to boot. Here are some benchmarks for iterating through an entire /24, /16 and /8-bit subnet.\ngoos: darwin goarch: amd64 pkg: github.com/wetware/casm/pkg/boot/crawl cpu: Intel(R) Core(TM) i7-1068NG7 CPU @ 2.30GHz BenchmarkCIDR/24-8 45287678\t24.31 ns/op\t0 B/op\t0 allocs/op BenchmarkCIDR/16-8 45160854\t23.83 ns/op\t0 B/op\t0 allocs/op BenchmarkCIDR/8-8 27968556\t41.16 ns/op\t0 B/op\t0 allocs/op In fact, at 41.16 ns for 16777216 IPs, it seems too fast. That’s 2.45e-06 nanoseconds per IP. Even with everything in a single cache line, can CPUs even go that fast? Or perhaps there’s some ALU hardware magic going on here? Ordinarily, I would take a peek at the assembly to see if the compiler is optimizing away the code we’re trying to measure, but that’s a rabbit hole I’d rather avoid at the moment.\nQuery for the Author: Are these benchmarks correct? If so, what accounts for this incredible performance? Is the ALU involved? CPU pipelining or vectorization, or some such?\nConclusion: Why Bother? Judging from the lack of relevant libraries on GitHub, it would seems the need for randomized IP enumeration is somewhat niche. As such, a few words on motivation seem like an appropriate way to conclude my first blog post.\nWetware is a minimal cluster environment that makes it easy to write distributed systems and applications. Wetware is distributed as a single static binary that runs a server process on each host in your cluster. The server is responsible for joining the cluster, after which it can share resources with other hosts, and export cluster-wide services to applications.\nWhat sets Wetware apart is that it is entirely peer-to-peer. There are no coordinators, no master nodes, and no central scheduler. No node is “special”, and there is no global cluster state to corrupt or synchronize. The upshot is that it is incredibly resilient and quite easy to reason about. For those of us developing Wetware, however, it presents a few challenges.\nOne such challenge is “bootstrapping”. When a Wetware server first starts, it must somehow discover the network address of existing peers. There are several ways of doing this, but a popular one is IP-crawling: send a UDP packet to a known port for each address in the configured subnet, and wait for a reply. Simple enough, and quite effective.\nBut here’s the problem: there’s a nasty tendency for hosts to join a cluster in groups. This is because generally speaking, host reboots aren’t as independent as we like to think. Moreover, we like clusters in large part for their horizontal scalability, i.e. the ability to quickly add more hardware to meet peak demand. So we also tend to add hardware in batches.\nTo make matters worse, host failures and horizontal scaling tend to occur when the system is under load. If we’re not careful, the addition of hardware intended to alleviate the load can instead cause cascading failures. The risk is especially high if each server in a batch of freshly-added hosts were to send their bootstrap UDP packets to the same hosts, in the same order, in unison.\nTo prevent this kind of failure, Wetware servers iterate through the subnet in pseudorandom order, and apply rate-limits to their outgoing packets. This ensures the bootstrapping load is spread evenly throughout the cluster. Even the busiest servers can generally handle one or two additional UDP packets.\nWetware’s bootstrap protocol is an integral part of its reliability, and there are a actually a lot of interesting subtleties. Maybe I’ll blog about it soon.\n",
  "wordCount" : "1607",
  "inLanguage": "en",
  "datePublished": "2022-11-18T09:09:10-05:00",
  "dateModified": "2022-11-18T09:09:10-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://lthibault.github.io/posts/random-cidr-iter/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "lthibau.lt",
    "logo": {
      "@type": "ImageObject",
      "url": "https://lthibault.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://lthibault.github.io" accesskey="h" title="lthibau.lt (Alt + H)">lthibau.lt</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Randomized enumeration of IP addresses in a subnet
    </h1>
    <div class="post-meta"><span title='2022-11-18 09:09:10 -0500 EST'>November 18, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>I recently encountered a problem that seemed trivial on the surface, and turned out to be challenging enough to warrant a blog post:</p>
<blockquote>
<p>Given a subnet, iterate through its addresses in pseudorandom order.</p>
</blockquote>
<h3 id="naive-approach">Naive Approach<a hidden class="anchor" aria-hidden="true" href="#naive-approach">#</a></h3>
<p>For small subnets like <code>10.8.1.0/24</code>, the naive implementation works well.  We enumerate each address and append it to a list, shuffle the list, and then range over the list.  The first step is the only one I had to stop and think about, but it ended up being quite straightforward.  Here&rsquo;s its implementation in Go, with some extra comments to make it more obvious:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">incrIP</span>(<span style="color:#a6e22e">ip</span> <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IP</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Iterate over ip&#39;s bytes in reverse order
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> len(<span style="color:#a6e22e">ip</span>) <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">--</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Increment the current byte.  If it wraps around to zero,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#75715e">// continue with the next byte, else we&#39;re done.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ip</span>[<span style="color:#a6e22e">i</span>]<span style="color:#f92672">++</span>; <span style="color:#a6e22e">ip</span>[<span style="color:#a6e22e">i</span>] &gt; <span style="color:#ae81ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>With a <code>/16</code> subnet, the list-shuffling approach remains feasible, but starts to feel sloppy.  It requires allocating a 256 KB list.  With <code>/8</code>, the size grows to 64 MB.  And if we&rsquo;re dealing with IPv6, that number can grow much larger.</p>
<p>Fortunately, there is a way to iterate through arbitrarily-large subnets with constant memory.  I can&rsquo;t imagine I&rsquo;m the first to discover this trick, but I confess to having felt a shivver of satisfaction when it clicked into place.  The intuition is simple:  generate a random bitmask and XOR it with the unmasked bits in the subnet.  The essential challenge boils down to some unobvious, albeit insanely satisfying, bit-twiddling.</p>
<h3 id="a-brief-aside--xor">A Brief Aside:  XOR<a hidden class="anchor" aria-hidden="true" href="#a-brief-aside--xor">#</a></h3>
<p>I love XOR; it&rsquo;s my favorite boolean operator.  Even after all these years, it strikes me as quirky when compared to the more pedestrian AND, OR and NOT, yet it seems to turn up <em>everywhere</em>, and for good reason!  XOR has algebraic properties that make it arguably <em>less</em> quirky and more well-behaved than most of it siblings, and incredibly useful.</p>
<p>It seems unnecessary to introduce a definition of XOR, given its familiarity to most developers, but it can be helpful to check its more interesting properties against a truth-table.  In essence, A ⊕ B is true if <strong>either</strong> A or B is true, but not both.</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>A ⊕ B</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>This naturally extends to bitwise operations on binary integers.  XOR-ing the 8-bit binary integer <code>0111 1111</code> with <code>1111 1110</code> produces <code>1000 0001</code>.  Each bit from the first integer is XORed with the corresponding bit on the second integer to produce the result.</p>
<p>Four properties of XOR deserve special mention.  First, A ⊕ 0 = A, for any A.  This follows from the definition of XOR.  In other words, XOR-ing by zero acts as the <strong>identity property</strong>.</p>
<p>Similarly, A ⊕ 1 = ¬A, for any A.  This also follows from the definition of XOR, and acts as an <strong>inverse property</strong>.</p>
<p>The third property we shall call the <strong>complementary property</strong>.  For any A, B and C, such that A ⊕ B = C, A ⊕ C = B and B ⊕ C = A.</p>
<p>This brings us to the fourth and final notable property:  the <strong>uniqueness property</strong>.  For any A, B, X and Y, if A ⊕ B = C and X ⊕ Y = C, then A = X and B = Y, or A = Y and B = X.  In other words, XOR-ing a pair of 8-bit integers produces an 8-bit integer that is unique to that pair.</p>
<blockquote>
<p><strong>Proof</strong> (by contradiction).  Let A ⊕ B = C.  By the complementary property, A ⊕ C = B.  Now, suppose there is an X ≠ B such that A ⊕ X = C.  Then, A ⊕ C = X, and we arrive at a contradiction. ⃞</p>
</blockquote>
<h3 id="xor-bit-mask-approach">XOR Bit-Mask Approach<a hidden class="anchor" aria-hidden="true" href="#xor-bit-mask-approach">#</a></h3>
<p>The uniqueness property turns out to be essential, as it provides us with a way of randomizing the enumeration-order of an integer range without resorting to list-construction.  Instead, we can generate a random mask, and then iterate through the integer range in-order, XOR-ing each integer with the mask.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">mask</span> = <span style="color:#ae81ff">0xd3</span>  <span style="color:#75715e">// random value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#ae81ff">256</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">i</span>^<span style="color:#a6e22e">mask</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We&rsquo;re now inches away from a solution.  The only wrinkle is that IP subnets are multiple bytes in length, and have a constant prefix that must <em>not</em> be modified by the XOR-mask.  In <code>10.8.1.0/24</code>, only the last 8 bits should be randomized, for example.</p>
<p>Let&rsquo;s start with an buggy implementation and refine it progressively.  Assume the subnet <code>10.8.1.0/24</code>.  The corresponding subnet mask is <code>255.255.255.0</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">/* BUG.  Modifies the subnet address prefix. */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">subnet</span> = <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IP</span>:   <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IP</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Mask</span>: <span style="color:#a6e22e">IPMask</span>{<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">0</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Create a random mask of the same length as an IPv4 address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mask</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">mask</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Range over subnet IPs
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ip</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">IP</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span>, <span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">IP</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">ip</span>[<span style="color:#a6e22e">i</span>] = <span style="color:#a6e22e">b</span>^<span style="color:#a6e22e">mask</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ip</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">incrIP</span>(<span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">IP</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If you run this code, you&rsquo;ll observe that the final byte of the printed addresses behaves as expected.  However, the constant prefix will be mangled with near certainty.  To remedy this, we&rsquo;ll need our identity and inverse properties.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">subnet</span> = <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IPNet</span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">IP</span>:   <span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">IP</span>{<span style="color:#ae81ff">10</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>},
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">Mask</span>: <span style="color:#a6e22e">IPMask</span>{<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">0</span>},
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Create a random mask of the same length as an IPv4 address
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">mask</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">rand</span>.<span style="color:#a6e22e">Read</span>(<span style="color:#a6e22e">mask</span>) <span style="color:#75715e">// let&#39;s say this now contains 42.124.33.77
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Get the inverse of the subnet mask.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">inverse</span> <span style="color:#f92672">:=</span> make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>copy(<span style="color:#a6e22e">inverse</span>, <span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">Mask</span>)               <span style="color:#75715e">// contains 255.255.255.0
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xor</span>(<span style="color:#a6e22e">inverse</span>, []<span style="color:#66d9ef">byte</span>{<span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>, <span style="color:#ae81ff">255</span>}) <span style="color:#75715e">// now contains 0.0.0.255
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Zero-out the 3 leftmost bytes in the random mask, corresponding
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// to the original (non-inverted) subnet mask.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#a6e22e">xor</span>(<span style="color:#a6e22e">mask</span>, <span style="color:#a6e22e">inverse</span>)  <span style="color:#75715e">// mask now contains 0.0.0.77
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ip</span> = make([]<span style="color:#66d9ef">byte</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">for</span> <span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">IP</span>) {
</span></span><span style="display:flex;"><span>    copy(<span style="color:#a6e22e">ip</span>, <span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">IP</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">xor</span>(<span style="color:#a6e22e">ip</span>, <span style="color:#a6e22e">mask</span>)  <span style="color:#75715e">// contains 10.8.1.x, where x = 77 ⊕ subnet.IP[3]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ip</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">incrIP</span>(<span style="color:#a6e22e">subnet</span>.<span style="color:#a6e22e">IP</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We define the helper function <code>xor</code> as follows:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">xor</span>(<span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">y</span> []<span style="color:#66d9ef">byte</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">range</span> <span style="color:#a6e22e">x</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">x</span>[<span style="color:#a6e22e">i</span>] ^= <span style="color:#a6e22e">y</span>[<span style="color:#a6e22e">i</span>]
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>And voila!  You now have pseudorandom iteration through a subnet with O(1) memory usage!  And it&rsquo;s blazing fast, to boot.  Here are some benchmarks for iterating through an entire <code>/24</code>, <code>/16</code> and <code>/8</code>-bit subnet.</p>
<pre tabindex="0"><code>goos: darwin
goarch: amd64
pkg: github.com/wetware/casm/pkg/boot/crawl
cpu: Intel(R) Core(TM) i7-1068NG7 CPU @ 2.30GHz
BenchmarkCIDR/24-8         	45287678	        24.31 ns/op	       0 B/op	       0 allocs/op
BenchmarkCIDR/16-8         	45160854	        23.83 ns/op	       0 B/op	       0 allocs/op
BenchmarkCIDR/8-8          	27968556	        41.16 ns/op	       0 B/op	       0 allocs/op
</code></pre><p>In fact, at 41.16 ns for 16777216 IPs, it seems <em>too</em> fast.  That&rsquo;s 2.45e-06 <em>nanoseconds</em> per IP.  Even with everything in a single cache line, can CPUs even go that fast?  Or perhaps there&rsquo;s some ALU hardware magic going on here?  Ordinarily, I would take a peek at the assembly to see if the compiler is optimizing away the code we&rsquo;re trying to measure, but that&rsquo;s a rabbit hole I&rsquo;d rather avoid at the moment.</p>
<blockquote>
<p><strong>Query for the Author:</strong> Are these benchmarks correct?  If so, what accounts for this incredible performance?  Is the ALU involved?  CPU pipelining or vectorization, or some such?</p>
</blockquote>
<h3 id="conclusion--why-bother">Conclusion:  Why Bother?<a hidden class="anchor" aria-hidden="true" href="#conclusion--why-bother">#</a></h3>
<p>Judging from the lack of relevant libraries on GitHub, it would seems the need for randomized IP enumeration is somewhat niche.  As such, a few words on motivation seem like an appropriate way to conclude my first blog post.</p>
<p><a href="https://github.com/wetware/ww">Wetware</a> is a minimal cluster environment that makes it easy to write distributed systems and applications.  Wetware is distributed as a single static binary that runs a server process on each host in your cluster.  The server is responsible for joining the cluster, after which it can share resources with other hosts, and export cluster-wide services to applications.</p>
<p>What sets Wetware apart is that it is entirely peer-to-peer.  There are no coordinators, no master nodes, and no central scheduler.  No node is &ldquo;special&rdquo;, and there is no global cluster state to corrupt or synchronize.  The upshot is that it is incredibly resilient and quite easy to reason about.  For those of us developing Wetware, however, it presents a few challenges.</p>
<p>One such challenge is &ldquo;bootstrapping&rdquo;.  When a Wetware server first starts, it must somehow discover the network address of existing peers.  There are several ways of doing this, but a popular one is IP-crawling:  send a UDP packet to a known port for each address in the configured subnet, and wait for a reply.  Simple enough, and quite effective.</p>
<p>But here&rsquo;s the problem:  there&rsquo;s a nasty tendency for hosts to join a cluster in <em>groups</em>.  This is because generally speaking, host reboots aren&rsquo;t as independent as we like to think.  Moreover, we like clusters in large part for their horizontal scalability, <em>i.e.</em> the ability to quickly add more hardware to meet peak demand.  So we also tend to add hardware in batches.</p>
<p>To make matters worse, host failures and horizontal scaling tend to occur when the system is under load.  If we&rsquo;re not careful, the addition of hardware intended to alleviate the load can instead cause cascading failures.  The risk is especially high if each server in a batch of freshly-added hosts were to send their bootstrap UDP packets to the same hosts, in the same order, in unison.</p>
<p>To prevent this kind of failure, Wetware servers iterate through the subnet in pseudorandom order, and apply rate-limits to their outgoing packets.  This ensures the bootstrapping load is spread evenly throughout the cluster.  Even the busiest servers can generally handle one or two additional UDP packets.</p>
<p>Wetware&rsquo;s bootstrap protocol is an integral part of its reliability, and there are a actually a lot of interesting subtleties.  Maybe I&rsquo;ll blog about it soon.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://lthibault.github.io">lthibau.lt</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
